# 2×2 主元块详解：为什么需要，什么时候用

## 一、为什么需要 2×2 主元块？

### 1.1 对称不定矩阵的挑战

考虑一个对称矩阵的 LDLᵀ 分解：
```
A = L D Lᵀ
```

如果只使用 **1×1 主元**（标量主元），会遇到以下问题：

#### 问题示例：
```
A = [ε   1]  其中 ε ≈ 0 (非常小的数)
    [1   ε]
```

使用 1×1 主元分解：
1. 选择 A[0,0] = ε 作为主元
2. 需要计算 1/ε → **数值爆炸**！
3. 即使 A 是非奇异的，分解也会失败

### 1.2 2×2 主元块的解决方案

使用整个 2×2 块作为主元：
```
将 A 看作一个 2×2 的块，直接求逆：
A⁻¹ = 1/(ε²-1) × [ε  -1]
                  [-1  ε]
```
这样避免了除以极小数的问题。

## 二、什么时候使用 2×2 主元块？

### 2.1 Bunch-Kaufman 算法的判定准则

MA27/MA57 使用 **Bunch-Kaufman 算法**，它的判定逻辑是：

```python
# 伪代码
α = (1 + √17) / 8 ≈ 0.640  # 魔数常数

# 对角元素
a₁₁ = |A[k,k]|

# 最大非对角元素
λ = max |A[i,k]| for i ≠ k

if a₁₁ ≥ α·λ:
    # 使用 1×1 主元
    pivot = A[k,k]
else:
    # 寻找最大的非对角元素 A[r,k]
    # 检查 A[r,r]
    a₂₂ = |A[r,r]|
    σ = max |A[i,r]| for i ≠ r, i ≠ k

    if a₁₁·a₂₂ ≥ α·λ²:
        # 使用 1×1 主元 A[k,k]
        pivot = A[k,k]
    elif a₂₂ ≥ α·σ:
        # 交换行列，使用 1×1 主元 A[r,r]
        swap(k, r)
        pivot = A[r,r]
    else:
        # 使用 2×2 主元块
        pivot_block = [A[k,k]  A[k,r]]
                      [A[r,k]  A[r,r]]
```

### 2.2 决策的核心思想

使用 2×2 块的**关键条件**：
1. **对角元素太小**：相对于非对角元素
2. **强耦合**：两个变量高度相关
3. **避免数值不稳定**：防止除以小数

## 三、2×2 主元块的数学原理

### 3.1 块分解形式

使用 2×2 块时，分解变为：
```
A = [L₁₁   0  ] [D₁   0 ] [L₁₁ᵀ  L₂₁ᵀ]
    [L₂₁  L₂₂] [0   D₂] [0     L₂₂ᵀ]
```

其中 D₁ 可能是 2×2 块：
```
D₁ = [d₁₁  d₁₂]
     [d₂₁  d₂₂]
```

### 3.2 惯性的计算

对于 2×2 块，需要计算其特征值：
```cpp
// 2×2 块的特征值
double trace = d11 + d22;
double det = d11*d22 - d12*d21;
double discriminant = trace*trace - 4*det;

if (discriminant >= 0) {
    // 两个实特征值
    λ₁ = (trace + sqrt(discriminant)) / 2;
    λ₂ = (trace - sqrt(discriminant)) / 2;

    // 更新惯性
    if (λ₁ > 0) positive_eigenvalues++;
    else if (λ₁ < 0) negative_eigenvalues++;
    else zero_eigenvalues++;

    if (λ₂ > 0) positive_eigenvalues++;
    else if (λ₂ < 0) negative_eigenvalues++;
    else zero_eigenvalues++;
}
```

## 四、实际例子

### 4.1 鞍点系统

优化中的 KKT 系统是典型的鞍点结构：
```
[H   -Aᵀ] [Δx]   [g]
[-A   0 ] [Δλ] = [c]
```

这个矩阵的特点：
- 主对角有**零块**（右下角）
- 强烈的**对称不定性**
- 需要 2×2 块来稳定分解

### 4.2 示例：小型 KKT 系统

```python
# 实际矩阵
A = [ 2  0  -1]
    [ 0  3  -1]
    [-1 -1   0]

# 使用 1×1 主元：最后一步遇到 0 主元，失败！
# 使用 2×2 主元：
# 选择最后的 2×2 块：
# [3  -1]
# [-1  0]
# 这个块是非奇异的（行列式 = -1），可以安全求逆
```

## 五、不同求解器的策略对比

### 5.1 使用 2×2 块的求解器

| 求解器 | 2×2 块支持 | 算法 | 优势 |
|--------|------------|------|------|
| **MA27** | ✅ | Bunch-Kaufman | 经典，内存效率高 |
| **MA57** | ✅ | 改进的 Bunch-Kaufman | 更好的数值稳定性 |
| **MUMPS** | ✅ | 多种策略 | 可选择不同分解 |
| **LAPACK** | ✅ | Bunch-Kaufman | 标准实现 |

### 5.2 不使用 2×2 块的求解器

| 求解器 | 限制 | 后果 |
|--------|------|------|
| **Eigen SimplicialLDLT** | 只有 1×1 主元 | 对鞍点系统不稳定 |
| **简单 Cholesky** | 只用于正定矩阵 | 不能处理不定系统 |

## 六、2×2 块的性能影响

### 6.1 优点
- **数值稳定性**：避免除以小数
- **保持对称性**：分解保持对称结构
- **准确的惯性**：能正确识别特征值符号

### 6.2 代价
- **更复杂的代码**：需要处理两种主元类型
- **略慢的速度**：2×2 块求逆比标量除法慢
- **内存模式**：不规则的访问模式

## 七、在优化中的重要性

### 7.1 内点法

内点法的 KKT 系统随着接近最优解变得越来越病态：
```
μ → 0 时，矩阵接近奇异
```
2×2 块能够：
- 稳定处理接近奇异的情况
- 保持正确的搜索方向
- 避免数值崩溃

### 7.2 信赖域方法

在信赖域子问题中：
```
(H + λI)d = -g
```
当 λ 接近 -λ_min(H) 时，矩阵接近奇异，需要 2×2 块来稳定求解。

## 八、总结

### 为什么需要 2×2 主元块？

1. **处理对称不定矩阵**：标量主元不够
2. **避免数值不稳定**：防止除以极小数
3. **保持惯性准确性**：正确识别特征值符号
4. **处理强耦合变量**：某些变量必须一起处理

### 什么时候使用？

当检测到：
- 对角元素相对于非对角元素太小（|a_ii| < α|a_ij|）
- 矩阵有鞍点结构
- 接近奇异但非奇异的情况

### Eigen 失败的原因

Eigen 的 SimplicialLDLT **不支持 2×2 块**，导致：
- 遇到小主元时数值不稳定
- 无法正确处理鞍点系统
- 惯性计算错误

这就是为什么专业的优化求解器（MA27/MA57/MUMPS）都实现了 2×2 主元块，而 Eigen 在优化问题上表现不佳的深层原因。